// au_top has two states: GAMEPLAY and TESTING
// au_top toggles between the states when centre_button is pressed (since users/players should not be able to access TEST mode)

module au_top (
    input clk,                    // 100MHz clock
    input rst_n,                  // reset button (active low)
    output led [8],               // 8 user controllable LEDs
    input usb_rx,                 // USB->Serial input
    output usb_tx,                // USB->Serial output
    input centre_button,          // Middle button on IO Shield
    input player1_button [4],     // IO Buttons for Player 1
    input player2_button [4],     // IO Buttons for Player 2
    input player1_button_powerup, // Player 1 Powerup Button
    input player1_button_sevenseg,// Player 1 7-Seg Button
    input player2_button_powerup, // Player 2 Powerup Button
    input player2_button_sevenseg,// Player 2 7-Seg Button
    input reset_button,           // Game Reset Button
    output finger_leds [4][4],    // LEDs to represent fingers
    output seven_seg_p1_sel [4],  // Common Cathode seven-segment display digit select for Player 1
    output seven_seg_p1_seg [7],  // Common Cathode seven-segment display segment LEDs for Player 1 (without decimal point)
    output seven_seg_p2_sel [4],  // Common Cathode seven-segment display digit select for Player 2
    output seven_seg_p2_seg [7]   // Common Cathode seven-segment display segment LEDs for Player 2 (without decimal point)
  ) {

  sig rst; // reset signal
  sig state_change; // Signal to switch between gameplay and testing

  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    button_conditioner button_cond;
    edge_detector edge (#RISE(1), #FALL(0));

    .rst(rst) {
      fsm state = {PLAY, TEST};
      game_main_logic gameplay (.player1_button(player1_button), .player2_button(player2_button), .player1_button_powerup(player1_button_powerup), .player1_button_sevenseg(player1_button_sevenseg), .player2_button_powerup(player2_button_powerup), .player2_button_sevenseg(player2_button_sevenseg), .reset_button(reset_button));
      // game_tester tester ();
    }
  }

  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset

    usb_tx = usb_rx;        // loop serial port

    button_cond.in = centre_button;
    edge.in = button_cond.out;
    state_change = edge.out;

    // Turn off all of the LEDs and 7-segment digits
    finger_leds = 4x{{4h0}};
    seven_seg_p1_sel = 4hf;
    seven_seg_p1_seg = 7b1111111;
    seven_seg_p2_sel = 4hf;
    seven_seg_p2_seg = 7b1111111;

    case (state.q) {
      state.PLAY:
        finger_leds = gameplay.finger_leds;
        seven_seg_p1_sel = gameplay.seven_seg_p1_sel;
        seven_seg_p1_seg = gameplay.seven_seg_p1_seg;
        seven_seg_p2_sel = gameplay.seven_seg_p2_sel;
        seven_seg_p2_seg = gameplay.seven_seg_p2_seg;

        if (state_change) {
          state.d = state.TEST;
        }

      state.TEST:
        if (state_change) {
          state.d = state.PLAY;
        }
    }

    led = 8h00;             // turn LEDs off
  }
}