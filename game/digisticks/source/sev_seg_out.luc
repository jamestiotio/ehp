module sev_seg_out (
    input clk,  // clock
    input rst,  // reset
    
    input turn, //current turn
    input state, //current state
    
    input powerup_chosen[4], //from regfile, reads register's value
    input literal_chosen[16],
    output seg_tolight[8],//or do i need these 2 outputs for both 7 segs
    output dig_tolight[4],
    output out
  ) {
  .clk(clk) {
    .rst(rst) {
      multi_seven_seg seg_display;
    }
  }

  always {
    if(turn == 0){
      if(state == game_fsm.POWERUP){
        case(powerup_chosen){
          4b0: seg_display.values = {5b10001,5b10000,5b10100,5b10101};//NOT 'Y'
          4b1: seg_display.values = {5b11111,5b01010,5b10001,5b01101};//AND
          4b10: seg_display.values = {5b10001,5b01010,5b10001,5b01101};//NAND
          4b11: seg_display.values = {5b11111,5b11111,5b10000,5b10010};//OR 
          4b100: seg_display.values = {5b11111,5b10001,5b10000,5b10010};//NOR
          4b101: seg_display.values = {5b11111,5b10011,5b10000,5b10010};//XOR
          4b110: seg_display.values = {5b10011,5b10001,5b10000,5b10010};//XNOR
          4b111: seg_display.values = {5b11111,5b11111,5b11111,5b10011};//'X'
          4b1000:seg_display.values = {5b10001,5b10000,5b10100,5b10011};//NOT 'X'
        }
        seg_tolight = ~seg_display.seg;
        dig_tolight = ~seg_display.sel;//irdk
      }
      //light up p1's 7 seg
    }
  }
}
